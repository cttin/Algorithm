## 定义
背包问题（Knapsack problem）是一种组合优化的NP完全问题。问题可以描述为：有N件物品和一个容量为V的背包。其中，第N件物品的费用是c[i]，价值是v[i]。求解将哪些物品装入背包可以使得价值总和最大。
## 分析
这是最基础的背包问题，其特点是：每种物品只有一个，可以选择放或者不放。
用子问题“将前i件物品放入容量为v的背包中”定义其状态：`f[i][v]`表示前i件物品恰放入一个容量为v的背包可以获得的最大价值，状态转移方程为：
```
f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}
```
基本上所有的背包问题都是尤其衍生出来的，针对其子问题，若只考虑第i件物品的策略（放或不放），那么就可以转化为一个只牵扯前i-1件物品的问题。如果不放第i件物品，那么问题就转化为“前i-1件物品放入容量为v的背包中”，价值为`f[i-1][v]`；如果放第i件物品，那么问题就转化为“前i-1件物品放入剩下的容量为`v-c[i]`的背包中”，此时能获得的最大价值就是`f[i-1][v-c[i]]`再加上通过放入第i件物品获得的价值`w[i]`。
如何实现上面的思路呢？
先是有一个主体循环`i=1..N`，每次计算出二维数组`f[i][0..V]`的所有值。如果只用一个数组`f[0..V]`，能不能保证第i次循环结束后`f[v]`中表示的就是我们定义的状态`f[i][v]`呢?`f[i][v]`是由`f[i-1][v]`和`f[i-1][v-c[i]]`两个子问题递推而来，能否保证在推`f[i][v]`时（也即在第i次主循环中推`f[v]`时）能够得到`f[i-1][v]`和`f[i-1][v-c[i]]`的值呢？事实上这就要求以`v=V..0`的顺序递推`f[v]`，这才能保证在递推`f[v]`时保存的是状态`f[i-1][v-c[i]]`的值。
```
for i=1..N
    for v=V..0
        f[v]=max{f[v], f[v-c[i]]+w[i]}
```
其中，`f[v]=max{f[v], f[v-c[i]]+w[i]}`（总的价值）就相当于上面状态转移方程中的`f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}`（第i件物品的价值），因为现在的`f[v-c[i]]`就相当于`f[i-1][v-c[i]]`。
## 初始化细节
在我们遇到最优解背包问题的时候，会有一些不大相同的问法，如：”恰好装满背包“、“没有要求要把背包装满”等等。
如果是第一种问法，要求恰好装满背包，那么在初始化时除了`f[0]`为0，其它`f[1..V]`均设为-∞，这样就可以保证最终得到的`f[N]`是一种恰好装满背包的最优解。因为初始化f数组其实就是在没有任何物品可以放入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量为0的背包可能被价值为0的nothing“恰好装满”，其它容量的背包均没有合法的解，属于未定义的状态，它们的值就都应该是-∞了。
如果并没有要求必须把背包装满，而是只希望价格尽量大，初始化时应该将`f[0..V]`全部设为0。
因为任何容量的背包都有一个合法解“什么都不装”，这个解的价值为0，所以初始时状态的值也就全部为0了。


